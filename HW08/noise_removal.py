import cv2
import math
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('lena.bmp', 0)
h, w = img.shape

noiseImgs = {}
snrResults = {}

def SNR(origin, noise):
    h, w = origin.shape
    hh, ww = noise.shape
    origin.astype(np.float64)
    origin = np.divide(origin, 255)
    noise.astype(np.float64)
    noise = np.divide(noise, 255)

    # compute original image's Mean
    sum = 0
    for i in range(h):
        for j in range(w):
            sum += origin[i][j]
    mu = sum / (h * w)

    # compute original image's Standard Deviation
    sum = 0
    for i in range(h):
        for j in range(w):
            sum += (origin[i][j] - mu)**2
    sigma = sum / (h * w)

    # compute noise image's Mean
    sum = 0
    for i in range(h):
        for j in range(w):
            sum += noise[i][j] - origin[i][j]
    mu_noise = sum / (h * w)

    # compute noise image's Standard Deviation
    sum = 0
    for i in range(h):
        for j in range(w):
            sum += (noise[i][j] - origin[i][j] - mu_noise)**2
    sigma_noise = sum / (h * w)

    snr = 10 * (math.log10(sigma) - math.log10(sigma_noise))
    print(snr)
    return snr

# Generate noisy images with gaussian noise ( amplitude of 10 and 30 ) 
gaussian_10 = np.zeros((h, w), np.uint8)
gaussian_30 = np.zeros((h, w), np.uint8)
mu, sigma = 0, 1
s1 = np.random.normal(mu, sigma, (h, w))

for i in range(h):
    for j in range(w):
        temp = img[i][j] + 10 * s1[i][j]
        if temp > 255:
            gaussian_10[i][j] = 255
        elif temp < 0:
            gaussian_10[i][j] = 0
        else:
            gaussian_10[i][j] = temp

for i in range(h):
    for j in range(w):
        temp = img[i][j] + 30 * s1[i][j]
        if temp > 255:
            gaussian_30[i][j] = 255
        elif temp < 0:
            gaussian_30[i][j] = 0
        else:
            gaussian_30[i][j] = temp

snrResults['gaussian_10'] = SNR(img, gaussian_10)
snrResults['gaussian_30'] = SNR(img, gaussian_30)
fig, axs = plt.subplots(1, 2, figsize=(8, 6))
axs[0].imshow(gaussian_10, interpolation='nearest', cmap = 'gray')
axs[0].set_title('gaussian noise - amplitude 10')
axs[1].imshow(gaussian_30, interpolation='nearest', cmap = 'gray')
axs[1].set_title('gaussian noise - amplitude 30')
plt.show()
cv2.imwrite('./gaussian_10/gaussian_10.png', gaussian_10)
cv2.imwrite('./gaussian_30/gaussian_30.png', gaussian_30)
noiseImgs['gaussian_10'] = gaussian_10
noiseImgs['gaussian_30'] = gaussian_30

# Generate noisy images with salt-and-pepper noise ( probability 0.1 and 0.05 )
salt_10 = np.zeros((h, w), np.uint8)
salt_05 = np.zeros((h, w), np.uint8)
s2 = np.random.uniform(0, 1, (h, w))

for i in range(h):
    for j in range(w):
        if s2[i][j] < 0.05:
            salt_05[i][j] = 0
        elif s2[i][j] > 0.95:
            salt_05[i][j] = 255
        else:
            salt_05[i][j] = img[i][j]
            
for i in range(h):
    for j in range(w):
        if s2[i][j] < 0.10:
            salt_10[i][j] = 0
        elif s2[i][j] > 0.90:
            salt_10[i][j] = 255
        else:
            salt_10[i][j] = img[i][j]

snrResults['salt_10'] = SNR(img, salt_10)
snrResults['salt_05'] = SNR(img, salt_05)
fig, axs = plt.subplots(1, 2, figsize=(8, 6))
axs[0].imshow(salt_10, interpolation='nearest', cmap = 'gray')
axs[0].set_title('salt and pepper noise - probability 0.1')
axs[1].imshow(salt_05, interpolation='nearest', cmap = 'gray')
axs[1].set_title('salt and pepper noise - probability 0.05')
plt.show()
cv2.imwrite('./salt_10/salt_10.png', salt_10)
cv2.imwrite('./salt_05/salt_05.png', salt_05)
noiseImgs['salt_10'] = salt_10
noiseImgs['salt_05'] = salt_05

# Use 3x3, 5x5 box filter on images generated by (a)(b)
def boxFiter33(noiseImg):
    # padding
    noisePadding = cv2.copyMakeBorder(noiseImg, 2, 2, 2, 2, cv2.BORDER_REFLECT)
    h, w = noisePadding.shape

    IBUF = np.full((w), 0)
    box33 = np.full(noiseImg.shape ,0)
    for j in range(w):
        IBUF[j] = int(noisePadding[1][j]) + int(noisePadding[2][j]) + int(noisePadding[3][j])  
        
    for i in range(2, h-2):
        for j in range(2, w-2):
            box33[i-2][j-2] = IBUF[j-1] + IBUF[j] + IBUF[j+1]
            box33[i-2][j-2] /= 9
    
        # update IBUF to next row
        for j in range(w):
            IBUF[j] = IBUF[j] - int(noisePadding[i-1][j]) + int(noisePadding[i+2][j])
    
    return box33

def boxFiter55(noiseImg):
    # padding
    noisePadding = cv2.copyMakeBorder(noiseImg, 2, 2, 2, 2, cv2.BORDER_REFLECT)
    h, w = noisePadding.shape

    IBUF = np.full((w), 0)
    box55 = np.full(noiseImg.shape ,0)
    for j in range(w):
        IBUF[j] = int(noisePadding[0][j]) + int(noisePadding[1][j]) + int(noisePadding[2][j]) + int(noisePadding[3][j]) + int(noisePadding[4][j])  
        
    for i in range(2, h-2):
        for j in range(2, w-2):
            box55[i-2][j-2] = IBUF[j-2] + IBUF[j-1] + IBUF[j] + IBUF[j+1] + IBUF[j+2]
            box55[i-2][j-2] /= 25
    
        # update IBUF to next row
        if i != w-3: 
            for j in range(w):
                IBUF[j] = IBUF[j] - int(noisePadding[i-2][j]) + int(noisePadding[i+3][j])
    
    return box55

for key, value in noiseImgs.items():
    output = boxFiter33(value)
    snrResults[key+'_box33'] = SNR(img, output)
    cv2.imwrite('./'+key+'/'+key+'_box33.png', output)

for key, value in noiseImgs.items():
    output = boxFiter55(value)
    snrResults[key+'_box55'] = SNR(img, output)
    cv2.imwrite('./'+key+'/'+key+'_box55.png', output)

# Use 3x3, 5x5 median filter on images generated by (a)(b)
def medianFiter(img, k, i, j):
    l = []
    if k == 3:
        for a in (-1, 0, 1):
            for b in (-1, 0, 1):
                l.append(img[i+a][j+b])
        l.sort()
        return l[4]
    elif k == 5:
        for a in (-2, -1, 0, 1, 2):
            for b in (-2, -1, 0, 1, 2):
                l.append(img[i+a][j+b])
        l.sort()
        return l[12]

for key, value in noiseImgs.items():
    noisePadding = cv2.copyMakeBorder(value, 2, 2, 2, 2, cv2.BORDER_REFLECT)
    output = np.full((h, w), 0)
    for i in range(2, 516-2):
        for j in range(2, 516-2):
            output[i-2][j-2] = medianFiter(noisePadding, 3, i, j)
    snrResults[key+'_median33'] = SNR(img, output)
    cv2.imwrite('./'+key+'/'+key+'_median33.png', output)

for key, value in noiseImgs.items():
    noisePadding = cv2.copyMakeBorder(value, 2, 2, 2, 2, cv2.BORDER_REFLECT)
    output = np.full((h, w), 0)
    for i in range(2, 516-2):
        for j in range(2, 516-2):
            output[i-2][j-2] = medianFiter(noisePadding, 5, i, j)
    snrResults[key+'_median55'] = SNR(img, output)
    cv2.imwrite('./'+key+'/'+key+'_median55.png', output)

# Use both opening-then-closing and closing-then opening filter on images generated by (a)(b)
kernel = np.array([[0, 1, 1, 1, 0],
                   [1, 1, 1, 1, 1],
                   [1, 1, 1, 1, 1],
                   [1, 1, 1, 1, 1],
                   [0, 1, 1, 1, 0]], np.uint8)

# opening-then-closing
for key, value in noiseImgs.items():
    output = cv2.morphologyEx(value, cv2.MORPH_OPEN, kernel)
    output = cv2.morphologyEx(output, cv2.MORPH_CLOSE, kernel)
    snrResults[key+'_open_close'] = SNR(img, output)
    cv2.imwrite('./'+key+'/'+key+'_open_close.png', output)

# closing-then-opening
for key, value in noiseImgs.items():
    output = cv2.morphologyEx(value, cv2.MORPH_CLOSE, kernel)
    output = cv2.morphologyEx(output, cv2.MORPH_OPEN, kernel)
    snrResults[key+'_close_open'] = SNR(img, output)
    cv2.imwrite('./'+key+'/'+key+'_close_open.png', output)

# print all of SNR
for key, value in snrResults.items():
    print(key, ":", value)